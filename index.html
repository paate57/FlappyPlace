<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flappy Place</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="container">
    <div id="sidebar">
      <h2>Flappy Place</h2>
      <div class="info">Canvas: 2000x2000 px</div>
      
      <h3>Colori</h3>
      <div class="palette" id="palette"></div>
      
      <h3>Cooldown</h3>
      <div id="cooldown">
        <div id="cooldown-bar"></div>
        <div id="cooldown-text">Pronto!</div>
      </div>
      
      <div class="controls">
        <button class="btn" id="toggle-grid">Mostra Griglia</button>
        <button class="btn" id="center-view">Centra Vista</button>
        <button class="btn" id="reset-zoom">Reset Zoom</button>
      </div>
      
      <div class="info">
        <strong>Controlli:</strong><br>
        • Click sinistro: disegna<br>
        • Click destro: sposta vista<br>
        • Scroll: zoom<br>
      </div>
      
      <div class="info" id="coords">Posizione: (0, 0)</div>
      <div class="info" id="fps">FPS: 0</div>
    </div>
    
    <div id="canvas-container">
      <canvas id="canvas"></canvas>
      
      <div id="zoom-controls">
        <button class="zoom-btn" id="zoom-in">+</button>
        <button class="zoom-btn" id="zoom-out">−</button>
      </div>
      
      <div id="status">
        <span class="status-dot status-disconnected" id="status-dot"></span>
        <span id="status-text">Connessione...</span>
      </div>
    </div>
  </div>

  <script>
    let CANVAS_SIZE = 2000;
    let COLORS = [];
    let COOLDOWN_MS = 5000;
    
    let selectedColor = 0;
    let cooldownUntil = 0;
    let showGrid = false;
    
    let viewX = 0;
    let viewY = 0;
    let scale = 1;
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
    
    let ws = null;
    let userId = null;
    
    // Buffer canvas completo
    let canvasData = null;
    let canvasBitmap = null;
    let isDirty = false;
    
    let lastFrameTime = performance.now();
    let fps = 0;

    function connect() {
      // WebSocket URL dinamico - funziona sia locale che su Render
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const host = window.location.host;
      const wsUrl = `${protocol}//${host}`;
      
      console.log('Connessione a:', wsUrl);
      ws = new WebSocket(wsUrl);
      
      ws.onopen = () => {
        updateStatus(true);
        console.log('Connesso al server');
      };
      
      ws.onmessage = async (event) => {
        const msg = JSON.parse(event.data);
        
        switch(msg.type) {
          case 'init':
            userId = msg.userId;
            CANVAS_SIZE = msg.canvasSize;
            COLORS = msg.colors;
            COOLDOWN_MS = msg.cooldown;
            initUI();
            requestRegion();
            break;
            
          case 'region':
            await loadRegion(msg.x, msg.y, msg.width, msg.height, new Uint8Array(msg.data));
            break;
            
          case 'pixelUpdates':
            msg.updates.forEach(({ x, y, color }) => {
              if (canvasData) {
                canvasData[y * CANVAS_SIZE + x] = color;
              }
            });
            for (const { x, y, color } of msg.updates) {
              await updateSinglePixel(x, y, color);
            }
            scheduleRender();
            break;
            
          case 'drawSuccess':
            cooldownUntil = msg.cooldownUntil;
            updateCooldown();
            break;
        }
      };
      
      ws.onclose = () => {
        updateStatus(false);
        console.log('Disconnesso - riconnessione tra 3s...');
        setTimeout(connect, 3000);
      };
      
      ws.onerror = (err) => {
        console.error('WebSocket error:', err);
      };
    }

    function initUI() {
      canvas.width = window.innerWidth - 250;
      canvas.height = window.innerHeight;
      
      viewX = (CANVAS_SIZE - canvas.width / scale) / 2;
      viewY = (CANVAS_SIZE - canvas.height / scale) / 2;
      
      const paletteEl = document.getElementById('palette');
      COLORS.forEach((color, i) => {
        const btn = document.createElement('button');
        btn.className = 'color-btn';
        btn.style.background = color;
        if (i === 0) btn.classList.add('selected');
        btn.onclick = () => selectColor(i);
        paletteEl.appendChild(btn);
      });
      
      canvasData = new Uint8Array(CANVAS_SIZE * CANVAS_SIZE);
      
      startRenderLoop();
    }

    function selectColor(index) {
      selectedColor = index;
      document.querySelectorAll('.color-btn').forEach((btn, i) => {
        btn.classList.toggle('selected', i === index);
      });
    }

    function requestRegion() {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      
      ws.send(JSON.stringify({
        type: 'getRegion',
        x: 0,
        y: 0,
        width: CANVAS_SIZE,
        height: CANVAS_SIZE
      }));
    }

    async function loadRegion(x, y, width, height, data) {
      if (!canvasData) return;
      
      for (let dy = 0; dy < height; dy++) {
        for (let dx = 0; dx < width; dx++) {
          const worldX = x + dx;
          const worldY = y + dy;
          if (worldX >= 0 && worldX < CANVAS_SIZE && worldY >= 0 && worldY < CANVAS_SIZE) {
            canvasData[worldY * CANVAS_SIZE + worldX] = data[dy * width + dx];
          }
        }
      }
      
      await updateBitmap();
      scheduleRender();
    }

    async function updateBitmap() {
      if (!canvasData) return;
      
      const offscreen = new OffscreenCanvas(CANVAS_SIZE, CANVAS_SIZE);
      const offCtx = offscreen.getContext('2d', { alpha: false });
      const imageData = offCtx.createImageData(CANVAS_SIZE, CANVAS_SIZE);
      
      for (let i = 0; i < canvasData.length; i++) {
        const colorIndex = canvasData[i];
        const color = COLORS[colorIndex];
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        
        const idx = i * 4;
        imageData.data[idx] = r;
        imageData.data[idx + 1] = g;
        imageData.data[idx + 2] = b;
        imageData.data[idx + 3] = 255;
      }
      
      offCtx.putImageData(imageData, 0, 0);
      canvasBitmap = await createImageBitmap(offscreen);
      isDirty = false;
    }

    async function updateSinglePixel(x, y, colorIndex) {
      if (!canvasBitmap) return;
      
      const offscreen = new OffscreenCanvas(CANVAS_SIZE, CANVAS_SIZE);
      const offCtx = offscreen.getContext('2d', { alpha: false });
      
      offCtx.drawImage(canvasBitmap, 0, 0);
      
      const color = COLORS[colorIndex];
      const r = parseInt(color.slice(1, 3), 16);
      const g = parseInt(color.slice(3, 5), 16);
      const b = parseInt(color.slice(5, 7), 16);
      
      const pixelData = offCtx.createImageData(1, 1);
      pixelData.data[0] = r;
      pixelData.data[1] = g;
      pixelData.data[2] = b;
      pixelData.data[3] = 255;
      
      offCtx.putImageData(pixelData, x, y);
      
      canvasBitmap = await createImageBitmap(offscreen);
    }

    async function drawPixel(x, y) {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      if (Date.now() < cooldownUntil) return;
      
      ws.send(JSON.stringify({
        type: 'drawPixel',
        x, y,
        color: selectedColor
      }));
      
      if (canvasData) {
        canvasData[y * CANVAS_SIZE + x] = selectedColor;
        await updateSinglePixel(x, y, selectedColor);
        scheduleRender();
      }
    }

    let renderScheduled = false;
    
    function scheduleRender() {
      if (!renderScheduled) {
        renderScheduled = true;
        requestAnimationFrame(render);
      }
    }
    
    function render() {
      renderScheduled = false;
      
      const now = performance.now();
      fps = Math.round(1000 / (now - lastFrameTime));
      lastFrameTime = now;
      document.getElementById('fps').textContent = `FPS: ${fps}`;
      
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      if (canvasBitmap) {
        ctx.imageSmoothingEnabled = false;
        
        const sx = Math.floor(viewX);
        const sy = Math.floor(viewY);
        const sw = Math.ceil(canvas.width / scale);
        const sh = Math.ceil(canvas.height / scale);
        
        const clippedSw = Math.min(sw, CANVAS_SIZE - sx);
        const clippedSh = Math.min(sh, CANVAS_SIZE - sy);
        
        const dx = -(viewX - sx) * scale;
        const dy = -(viewY - sy) * scale;
        
        ctx.drawImage(
          canvasBitmap,
          sx, sy, clippedSw, clippedSh,
          dx, dy, clippedSw * scale, clippedSh * scale
        );
      }
      
      if (showGrid && scale >= 4) {
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 1;
        
        const sx = Math.floor(viewX);
        const sy = Math.floor(viewY);
        const dx = -(viewX - sx) * scale;
        const dy = -(viewY - sy) * scale;
        
        const startX = sx;
        const startY = sy;
        const endX = Math.ceil(viewX + canvas.width / scale);
        const endY = Math.ceil(viewY + canvas.height / scale);
        
        ctx.beginPath();
        for (let x = startX; x <= endX; x++) {
          const screenX = dx + (x - sx) * scale + 0.5;
          ctx.moveTo(screenX, 0);
          ctx.lineTo(screenX, canvas.height);
        }
        for (let y = startY; y <= endY; y++) {
          const screenY = dy + (y - sy) * scale + 0.5;
          ctx.moveTo(0, screenY);
          ctx.lineTo(canvas.width, screenY);
        }
        ctx.stroke();
      }
    }

    function startRenderLoop() {
      function loop() {
        scheduleRender();
        requestAnimationFrame(loop);
      }
      loop();
    }

    function updateCooldown() {
      const remaining = Math.max(0, cooldownUntil - Date.now());
      const progress = remaining / COOLDOWN_MS;
      
      const bar = document.getElementById('cooldown-bar');
      const text = document.getElementById('cooldown-text');
      
      if (remaining > 0) {
        bar.style.width = (progress * 100) + '%';
        text.textContent = (remaining / 1000).toFixed(1) + 's';
        setTimeout(updateCooldown, 100);
      } else {
        bar.style.width = '0%';
        text.textContent = 'Pronto!';
      }
    }

    function updateStatus(connected) {
      const dot = document.getElementById('status-dot');
      const text = document.getElementById('status-text');
      dot.className = 'status-dot ' + (connected ? 'status-connected' : 'status-disconnected');
      text.textContent = connected ? 'Connesso' : 'Disconnesso';
    }

    // Interazioni
    let pointerDown = false;
    let pointerId = null;
    let pointerButton = null;
    let downClientX = 0;
    let downClientY = 0;
    let lastClientX = 0;
    let lastClientY = 0;
    let isDragging = false;

    canvas.addEventListener('pointerdown', (e) => {
      canvas.setPointerCapture(e.pointerId);
      pointerDown = true;
      pointerId = e.pointerId;
      pointerButton = e.button;
      downClientX = lastClientX = e.clientX;
      downClientY = lastClientY = e.clientY;
      isDragging = false;
      e.preventDefault();
    });

    canvas.addEventListener('pointermove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const worldX = Math.floor(viewX + x / scale);
      const worldY = Math.floor(viewY + y / scale);
      document.getElementById('coords').textContent = `Posizione: (${worldX}, ${worldY})`;

      if (!pointerDown || e.pointerId !== pointerId) return;

      const moved = Math.hypot(e.clientX - downClientX, e.clientY - downClientY);
      if (!isDragging && pointerButton === 2 && moved > 5) {
        isDragging = true;
        canvas.style.cursor = 'grabbing';
      }

      if (isDragging) {
        const dx = e.clientX - lastClientX;
        const dy = e.clientY - lastClientY;
        viewX = Math.max(0, Math.min(CANVAS_SIZE - canvas.width / scale, viewX - dx / scale));
        viewY = Math.max(0, Math.min(CANVAS_SIZE - canvas.height / scale, viewY - dy / scale));
        lastClientX = e.clientX;
        lastClientY = e.clientY;
      }
    });

    canvas.addEventListener('pointerup', (e) => {
      if (!pointerDown || e.pointerId !== pointerId) return;
      try { canvas.releasePointerCapture(e.pointerId); } catch (err) {}
      pointerDown = false;

      if (!isDragging && pointerButton === 0) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const worldX = Math.floor(viewX + x / scale);
        const worldY = Math.floor(viewY + y / scale);
        if (worldX >= 0 && worldX < CANVAS_SIZE && worldY >= 0 && worldY < CANVAS_SIZE) {
          drawPixel(worldX, worldY);
        }
      } else if (isDragging) {
        isDragging = false;
        canvas.style.cursor = 'crosshair';
      }

      pointerButton = null;
      pointerId = null;
    });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const oldScale = scale;
      scale = Math.max(0.5, Math.min(32, scale * (e.deltaY > 0 ? 0.9 : 1.1)));
      
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      viewX += mouseX / oldScale - mouseX / scale;
      viewY += mouseY / oldScale - mouseY / scale;
      
      viewX = Math.max(0, Math.min(CANVAS_SIZE - canvas.width / scale, viewX));
      viewY = Math.max(0, Math.min(CANVAS_SIZE - canvas.height / scale, viewY));
    });

    document.getElementById('toggle-grid').addEventListener('click', () => {
      showGrid = !showGrid;
      document.getElementById('toggle-grid').textContent = showGrid ? 'Nascondi Griglia' : 'Mostra Griglia';
    });
    
    document.getElementById('center-view').addEventListener('click', () => {
      viewX = (CANVAS_SIZE - canvas.width / scale) / 2;
      viewY = (CANVAS_SIZE - canvas.height / scale) / 2;
    });
    
    document.getElementById('reset-zoom').addEventListener('click', () => {
      scale = 1;
    });
    
    document.getElementById('zoom-in').addEventListener('click', () => {
      scale = Math.min(32, scale * 1.5);
    });
    
    document.getElementById('zoom-out').addEventListener('click', () => {
      scale = Math.max(0.5, scale / 1.5);
    });
    
    connect();
  </script>
</body>
</html>